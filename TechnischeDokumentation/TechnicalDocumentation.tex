\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{german}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage[german]{babel}
\renewcommand{\listfigurename}{}
\usepackage{geometry}
\usepackage{listings}
\usepackage{hyperref}
\usepackage[onehalfspacing]{setspace}
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{DejaVuSans}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{float}

\renewcommand*{\familydefault}{\sfdefault}
\geometry{verbose,a4paper,tmargin=35mm,bmargin=35mm,lmargin=25mm,rmargin=25mm}
\author{Dominik Heeb, Fabian Keller}
\title{Dynamic Paralle Checker}
\pagestyle{fancy}
\fancyhead{}
\fancyhead[L]{Dynamic Parallel Checker}
\fancyhead[R]{Domink Heeb, Fabian Keller}
\fancyfoot{}
\fancyfoot[R]{Seite \thepage}
\definecolor{backcolor}{rgb}{0.95,0.95,0.92}
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}
\lstset{language=[Sharp]C,
captionpos=b,
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\normalsize,}

\usepackage{amsmath}
\usepackage[some]{background}
\usepackage{lipsum}

\definecolor{titlepagecolor}{cmyk}{1,.20,0,.25}

\DeclareFixedFont{\bigsf}{T1}{phv}{b}{n}{1.5cm}

\backgroundsetup{
scale=1,
angle=0,
opacity=1,
contents={\begin{tikzpicture}[remember picture,overlay]
 \path [fill=titlepagecolor] (-0.5\paperwidth,5) rectangle (0.5\paperwidth,10);  
\end{tikzpicture}}
}
\makeatletter                       
\def\printauthor{%                  
    {\LARGE Studenten:\\\vspace{10pt}
    \large \@author \\\vspace{20pt}
    \LARGE Dozent:\\\vspace{10pt}
    \large Prof. Dr. Luc Bläser \\
	\texttt{lblaeser@hsr.ch}}}            
\makeatother
\author{%
    Fabian Keller \\
    Semester 5 \\
    \texttt{f3keller@hsr.ch}\vspace{15pt} \\
    Dominik Heeb \\
    Semester 5 \\
    \texttt{d1heeb@hsr.ch}
    }

\begin{document}
\begin{titlepage}
\BgThispage
\newgeometry{left=1cm,right=4cm}
\vspace*{2cm}
\noindent
\textcolor{white}{\bigsf Dynamic Parallel Checker\\[0.5cm] \begin{huge}Semesterarbeit - Technische Dokumentation\end{huge}}
\vspace*{2.0cm}\par
\noindent
\begin{minipage}{0.35\linewidth}
    \begin{flushright}
        \printauthor
    \end{flushright}
\end{minipage} \hspace{15pt}
%
\begin{minipage}{0.02\linewidth}
    \rule{1pt}{300pt}
\end{minipage} \hspace{40pt}
%
\begin{minipage}{0.6\linewidth}
\begin{center}
\begin{huge}
Eine Studie über Dynamic Parallel Checking Methoden
\end{huge}
\end{center}
\end{minipage}
\end{titlepage}
\restoregeometry

\newpage
\tableofcontents 
\newpage

\section{Abstract}
\begin{flushleft}
Das Projekt "Dynamic Parallel Checker" behandelt die Entwicklung und Implementation eines Algorithmus zur Erkennung von Nebenläufigkeitsfehlern (Race Conditions) während der Laufzeit(dynamisch). Der entwickelte Algorithmus basiert auf dem Vector Clock Algorithmus von Colin Firdge und Friedmann Mattern \cite{acsc}. Durch den Vector Clock Algortihmus wird erlaubt, Schreib/Lesezugriffe in eine relative Ordnung zu setzen (Happend-Before, Concurrent). Diese Ordnung zeigt auf, wo Zugriffe Concurrent zueinander auf die selben Ressourcen durchgeführt werden (Race Conditions). Neben den Lese - / Schreibzugriffen wird überwacht, wann ein Lock / Unlock auf welche Ressource durchgeführt wird, sowie ein Thread oder Task gestartet wird. Dies vermindert die Anzahl Fehlmeldungen. Locks welche ausgeführt werden, werden in einer Lock-History gehalten. Diese erlaubt es diese als Synchronisationspunkte für den Vector Clock Algorithmus zu verwenden.\\
Die Implementation des Algorithmus erlaubt es Microsoft Intermediate Language Code (MSIL) zu überwachen. Dieser Code wird von allen .Net Sprachen verwendet. Daher erlaubt die Implementation die Überwachung von .Net entwickelten Applikationen. Um eine Information über die für den Algorithmus wichtigen Lese- / Schreibzugriffe zu erhalten, wird der MSIL Code über das Framework Mono.Cecil instrumentiert. Dazu wird der bestehende MSIL Code, um Codestellen erweitert, welche an die implementierte Dynamic Parallel Checker Library die Informationen übergeben.
\end{flushleft}
\newpage
\section{Technischer Bericht}
\subsection{Einleitung und Übersicht}
Dieses Kapitel beinhaltet eine Beschreibung der verwendeten Konzepte und Technologien dieses Projekts. Für das Verständnis des gesamten technischen Berichts empfehlen wir das Lesen dieses Teils. Bei bereits vorhandener Fachkenntnis bezüglich der Thematik kann dieser Teil gerne übersprungen werden und direkt die Implementation betrachtet werden.
\subsubsection{Dynamic Checker}
\begin{flushleft}
Um Race Conditions (sh. \ref{race_conditons}) zu erkennen, gibt es verschiedene Ansätze. Zwei davon sind, der Dynamic Checker und der Static Checker. In diesem Projekt
wird ein Dynamic Checker entwickelt. Ein dynamic Checker hat die Aufgabe, Race Conditions zur Laufzeit (dynamic) zu erkennen. Der Static Checker
im Gegensatz behandelt das Erkennen zur Entwicklungszeit. Um einen Dynamic Checker realisieren zu können, muss ein fertiges Programm instrumentiert werden.
Mit Instrumentation ist gemeint, dass der Kompilierte Code angepasst wird, so dass er während der Laufzeit einen Erkennungsalgorithmus ausführen kann, jedoch nicht das Verhalten des Programms verändert.\\
Der Checker analysiert hauptsächlich Lese- und Schreibzugriffe auf Variablen. Um die Präzision zu erhöhen, müssen auch Lock/ Unlock und Thread.Start usw. ausgelesen werden.\\
Mehr informationen dazu unter: \ref{vector_algorithm} Vector Clock Algorithmus
\end{flushleft}
\subsubsection{Race Condition}\label{race_conditons}
\begin{flushleft}
Bei Race Conditions handelt es sich um Speicherzugriffsfehler. Diese können durch richtige synchronisation (Codeteile, in welchen nur ein Thread gleichzeitig arbeiten kann) verhindert werden. In \autoref{fig:exampleRaceCondition} wird ein Code beschrieben, welcher diese Synchronisation komplett weglässt und daher Race Conditions entstehen.
\begin{figure}[H]
\centering
\begin{tabular}{|cc|}
\hline
\multicolumn{2}{|c|}{Konto = 100} \\ 
 &  \\ 
Thread 1 & Thread 2 \\ 
Konto + 200 & Konto - 100 \\ 
\hline
\end{tabular}
\caption[Beispiel Race Condition]{Ein unsynchronisierter Zugriff auf ein Konto}
\label{fig:exampleRaceCondition}
\end{figure}
Wenn zwei Threads den Code unter \autoref{fig:exampleRaceCondition} parallel ausführen, ist nicht deterministisch welcher Thread wann durchgeführt wird. Die Situation in \autoref{fig:exampleRaceCondition2} kann dadurch entstehen. Dabei erfährt der zweite Thread nicht, das der erste Thread den Wert angepasst hat und überschreibt den Wert mit seinen falschen Daten.\\\newpage
\begin{figure}[H]
\centering
\begin{tabular}{|cc|}
\hline
Thread 1 & Thread 2\\
Lesen Konto = 100 & \\
& Lesen Konto = 100\\
Addieren 100 + 200 & Addieren 100 - 100\\
Speichern 300 &\\
& Speichern 0\\
\multicolumn{2}{|c|}{Konto = 0}\\
\hline
\end{tabular}
\caption[Race Condition]{Ablauf eines unnsynchronisierten Zugriff}
\label{fig:exampleRaceCondition2}
\end{figure}
Race Conditions wie unter \autoref{fig:exampleRaceCondition2} sind gefährlich, da kein effektiver Fehlzustand im System ensteht, sondern Werte nicht richtig angepasst werden. Race Conditions zeichnen sich auch daher aus, dass sie stark vom Verarbeitungsablauf abhängen und daher nicht immer auftreten müssen. Wenn also die Threads in \autoref{fig:exampleRaceCondition2} in der richtigen Reihenfolge verarbeitet werden, wird kein Fehler entstehen.\\

\end{flushleft}
\subsubsection{Vector Clock}
\begin{flushleft}
Die einzelnen Lese- und Schreibzugriffe in einem System können asynchron in unterschiedlichen Threads ablaufen und dadurch nicht in eine totale Ordnung gebracht werden. Um nun jedem einzelnen Zugriff einen Zeitstempel zuzuordnen verwenden wir eine Vector Clock. Diese Vector Clock wird benötigt um eine Aussage über die Nebenläufigkeit der einzelnen Zugriffe zu machen.\\
Die Vector Clock basiert auf der Lamport's Clock von Leslie B. Lamport. Jeder Teilnehmer in einem System, in unserem Fall wären dies die einzelnen Threads, besitzt ein eigener Zeitstempel. Der eigene Zeitstempel kann unabhängig inkrementiert werden. Eine Synchronisation zwischen den Zeitstempeln der Threads findet jedoch nur statt wenn ein Synchronisationspunkt vorliegt. Ein Synchronisationspunkt ist z.B. wenn ein Thread 1 ein Lock auf ein Objekt a macht und zuvor ein anderer Thread 2 ein Unlock auf das Objekt a gemacht hat. Dadurch ist sichergestellt, dass jeder Zugriff vor dem Unlock von Thread 1 sicher vor jedem Zugriff nach dem Lock von Thread 2 stattgefunden hat. In diesem Fall wird nun der Zeitstempel von Thread 2 mit dem Zeitstempel von Thread 1 synchronisiert. Der Zeitstempel von Thread 1 bleibt wie gehabt. Mehr Informationen über die einzelnen Synchronisationspunkte finden Sie im Kapitel \ref{implementation} Implementation.\\
Die Vector Clock erweitert die Lamport Clock nun dadurch, dass jeder Thread nicht nur einen globalen Zeitstempel besitzt sondern einen Vektor, der für jeden Thread einen eigenen Zeitstempel mitführt. D.h. jeder Thread besitzt nun einen eigenen Vektor mit den Zeitstempeln der anderen Threads. Jedoch befindet sich darin nicht der aktuelle Zeitstempel sondern der Zeitstempel der letzten Synchronisation mit dem jeweiligen Thread. Mit Hilfe der Vector Clock kann nun eine Aussage über die Nebenläufigkeit der einzelnen Lese- und Schreibzugriffe eines Thread gemacht werden.\\
Beispiel einer Vector Clock:\\
\[
	\begin{pmatrix}
		ThreadId_1 & 2\\
		ThreadId_2 & 0\\
		ThreadId_3 & 3\\
		... & ...
	\end{pmatrix}
\]
\end{flushleft}
\subsubsection{Happened-Before Beziehung}
\begin{flushleft}
Um mit Hilfe der Vector Clock die Nebenläufigkeit von Lese- und Schreibzugriffe zu bestimmen, verwenden wir die Happened-Before Beziehung von Leslie B. Lamport. Diese Beziehung wird in der Lamport Clock und in der Vector Clock verwendet um eine partielle Ordnung innerhalb mehreren Ereignissen herzustellen. Bei neben läufigen Programmen kann keine totale Ordnung erreicht werden, daher muss mit einer partiellen Ordnung gearbeitet werden. Unserem Algorithmus genügt die partielle Ordnung soweit, da ihn lediglich die Zugriffe interessieren, die neben läufig stattgefunden haben. \\
Die Happened-Before Beziehung vergleicht die Zeitstempel von zwei unterschiedlichen Zugriffen und kann dann eine Aussage darüber machen, ob diese nun neben läufig oder zwingend nacheinander stattgefunden haben. Folgende Eigenschaften definieren die Happened-Before Beziehung:
\begin{itemize}
\item Auf demselben Thread oder Task: a -> b wenn die Zeit von a < b. (Zeit ist durch Vector Clock gegeben)
\item Wenn eine Synchronisation zwischen zwei Threads oder Tasks durchgeführt wurde, dann a -> b wenn a der Thread oder Task ist von dem aus synchronisiert wird und b der Thread oder Task ist zu dem synchronisiert wird.
\item Für drei Zugriffe mit Synchronisation a, b, c, wenn a -> b und b -> c, dann a -> c (Transitivität)
\end{itemize}
Die Happened-Before Beziehung kann somit eine Aussage darüber machen, ob zwischen zwei unterschiedlichen Lese- oder Schreibzugriffen eine Synchronisation stattgefunden hat. Die Synchronisation zeigt, dass diese Zugriffe zwingend sequentiell abgelaufen sind und dadurch keine potenzielle Race Condition darstellen können. Die Zugriffe können folgende Beziehungen zueinander haben:\\[0.5cm]
\textbf{ Happened Before}\\[0.2cm]
\end{flushleft}
\begin{center}
\begin{tabular}{ c c }
  (x1, x2, x3, ...) -> (y1, y2, y3, ...) \\
  y1 >= x1 \\
  y2 >= x2 \\
  y3 >= x3 \\
  ... >= ... \\[0.2cm]
\end{tabular}
\end{center}
\begin{flushleft}
Der Zeitstempel eines Threads 1 in einer Vector Clock ist grösser oder gleich (>=) dem Zeitstempel des selben Threads 1 in der Vector Clock von Thread 2. Mindestens eine Kompontente der gesamten Vector Clock muss aber echt grösser (>) sein als in der anderen Vector Clock. In dieser Beziehung hat sicher eine Synchronisation zwischen den beiden Threads 1 und 2 stattgefunden und dadurch sind diese beiden Zugriffe keine potenzielle Race Condition.\\
Beispiel (T1 happened before T2):\\
\[
	T1 = \begin{pmatrix}
		T1 & 1\\
		T2 & 0\\
	\end{pmatrix}
	, T2 = \begin{pmatrix}
		T1 & 1\\
		T2 & 2\\
	\end{pmatrix}
\]
\\[0.5cm]
\textbf{Concurrent}\\[0.2cm]
Concurrent bedeutet, dass zwischen zwei Zugriffen auf zwei unterschiedlichen Threads keine Synchronisation durch z.B. einen Lock geschah. Diese Zugriffe können eine potentielle Race Condition darstellen, falls sie auf die selbe Ressource zugegriffen haben.\\
Sollten also beim Vergleich der Vector Clocks von zwei Zugriffen nicht alle Elemente aus Vektor 1 grösser gleich (>=) oder alle Elemente kleiner gleich (<=) sein wie das dazugehörige Element im Vektor 2, passierten diese Zugriffe neben läufig. Mit anderen Worten, wenn die erste Definition von "Happened-Before" auf die Vector Clocks nicht angewendet werden kann. Unser Algorithmus interessiert sich genau für diese Zugriffspaare und daher ist die Happened-Before Beziehung zentral für das Funktionieren des Algorithmus. \\
Beispiel:\\
\[
	T1 = \begin{pmatrix}
		T1 & 2\\
		T2 & 1\\
	\end{pmatrix}
	, T2 = \begin{pmatrix}
		T1 & 1\\
		T2 & 2\\
	\end{pmatrix}
\]
\\[0.5cm]
\end{flushleft}
\subsubsection{Microsoft IL Code}\label{chapter_IL}
\begin{flushleft}
Der Microsoft IL (Intermediate Language) Code wird verwendet um einen Zwischencode, zwischen dem Compiler und dem Prozessor zu bilden. Da der IL Code vereinheitlicht definiert ist, ist er unabhängig vom verwendeten Prozessor. In diesem Zustand wird das Programm zum Kunden ausgeliefert und erst auf der Maschine dur einen JIT (Just in Time) Compiler zur Laufzeit kompiliert. Dieses Verfahren besitzt den Vorteil, dass der Code auf das jeweilige System abgestimmt wird und dadurch die Funktionen des Prozessors optimal ausnützt. Der Nachteil ist jedoch der Performanceverlust, da jede Methode vor dem Ausführen noch kompiliert werden muss.\\
Für die Instrumentation, welche für den Dynamic Parallel Checker verwendet wird, ist der IL Code ideal, da er vereinheitlicht ist und daher nur eine Implementation entwickelt werden muss, welche für alle .Net Sprachen, sowie jedes Laufzeitsystem welches .Net unterstützt funktioniert.\newpage
Der MSIL Code ist Stack-basiert. Dies bedeutet das alle Operationen auf einem Stack durchgeführt werden, welcher nach dem LIFO Prinzip (Last In, First Out) arbeitet. Der Stack wird dazu verwendet die Werte vorzubereiten, zu verarbeiten und wieder vom Stack abzubauen. \autoref{example_stack} zeigt wie eine Operation durchgeführt wird und in welchen Schritten die Parameter auf dem Stack vorbereitet werden müssen\\
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{images/BeispielStack.png}
\caption{Beispiel einer Minus Operation mit den Parametern (5,2)}
\label{example_stack}
\end{figure}
Eine Instruktion im MSIL Code setzt sich jeweils aus einem OpCode und einem Operand zusammen.
\begin{lstlisting}
ldsflda    class TestProgram.NewObject TestProgram.Program::_obj1
\end{lstlisting}
In diesem Beispiel eines IL Code ist "ldsflda" der OpCode und "class TestProgram.NewObject TestProgram.Program::\_obj1" der Operand. Der OpCode (Operation Code) identifiziert was die Operation durchführen soll. Hier "ldsflda" (Load Static Field Address). Dabei wird vom Operand definierten Static Field die Speicheradresse ausgelesen und auf den Stack gelegt. Der Operand ist daher jeweils die Ressource welche für den OpCode verwendet wird. Der Typ des Operand ist durch den OpCode definiert.\\
Um erfolgreich den Source Code für den Dynamic Parallel Checker zu instrumentieren (sh. \autoref{example_injection}), muss der Aufbau des Stacks immer sichergestellt werden. Daher müssen Werte um Sie aus dem Stack herauszulesen, immer dupliziert werden, damit das Programm erfolgreich durchgeführt werden kann.\\
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{images/BeispielInjection.png}
\caption{Beispiel Code Injection, Stack Verhalten}
\label{example_injection}
\end{figure}
In \autoref{example_injection} ist ein Beispiel dargestellt, wie eine Injection den Stack verwaltet und dabei die benötigte Information "obj" aus dem Stack extrahiert und den Ursprungszustand wiederherstellt. Da bei einem LIFO Stack nur auf das oberste Element zugegriffen werden kann, wird der Top-Wert "value" in eine lokale Variable gespeichert. Nach dem Abbau des duplizieren "obj" wird der Wert wieder aus der Variable auf den Stack gelegt.
\end{flushleft}
\subsection{Implementation}\label{implementation}
In diesem Kapitel wird die Implementation des Dynamic Prallel Checker genauer erklärt. Unter \ref{example} ist das Beispiel beschrieben an welchem, in den folgenden Kapitel, die Funktion des Dynamic Parallel Checkers beschrieben wird. Der Dynamic Parallel Checker wurde mit C\#.Net entwickelt.
\newpage
\subsubsection{Beispiel}\label{example}
\begin{flushleft}
Der Vektor Clock Algorithmus wird in diesem Kapitel mit Hilfe von folgendem Pseudo-Code Beispiel genauer erläutert.\\
\begin{figure}[H]
\begin{singlespace}
\begin{lstlisting}
//... Deklaration a,b,locka,lockb...

Thread.Start(() =>		// start thread2 (T2)
{
	lock(lockb) {
		b = 3;
	}
	b = 4;
	lock(locka) {
		Console.WriteLine(a);
	}
});
Thread.Start(() =>		// start thread3 (T3)
{
	lock(locka) {
		a = 2;
	}
	b = 5;
	lock(lockb) {
		Console.WriteLine(b);
	}
})
lock(locka) {
	a = 3;
}
lock(lockb) {
	b = 6;
}
Console.WriteLine(a);
\end{lstlisting}
\end{singlespace}
\caption{Beispiel für die Erklärung des Algorithmus}\label{basic_example}
\end{figure}
Da der Code in \autoref{basic_example} asynchron durchgeführt wird, werden die 3 enstehenden Thread parallel ausgeführt. \autoref{basic_example_parallel} zeigt was die einzelnen Threads parallel durchführen. "w( ), r( )" stehen für Write und Read Vorgänge des Threads. Der Buchstabe in der Klammer für die Ressource.
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{images/VectorCheckingAlgorithm.png}
\caption{Darstellung der parallelen Vorgänge von \autoref{basic_example}}
\label{basic_example_parallel}
\end{figure}
\end{flushleft}
\newpage
\subsubsection{Instrumentation}
\begin{flushleft}
Für die Durchführung des Vector Clock Algorithmus (sh. Kapitel \ref{vector_algorithm}) ist es wichtig die Informationen über Lese- / Schreibzugriffe sowie Locks und Thread.Starts zu erhalten. Dazu muss der bestehende IL Code angepasst (instrumentiert) werden, damit er diese Informationen preisgibt. Dazu wird der Code analysiert und an Stellen mit wichtigen Zugriffen um Code erweitert. Wie in Kapitel \ref{chapter_IL} bereits beschrieben muss dabei der korrekte Aufbau des Stack jederzeit sichergestellt werden. Für die Instrumentation des Codes wird die Library Mono.Cecil aus dem Mono Projekt verwendet. Die Library erlaubt es den IL Code zu lesen und zu bearbeiten. 
\begin{figure}[H]
\centering
\begin{lstlisting}[language=CIL,backgroundcolor=\color{backcolor}]
IL_001a:  box        [mscorlib]System.Int32
IL_001f:  stsfld     object TestProgram.Program::_a
\end{lstlisting}
\caption{Beispiel ohne Instrumentation}\label{example_codeWithoutInstrum}
\end{figure}
\autoref{example_codeWithoutInstrum} zeigt ein Beispiel, eines typischen Schreibzugriff im MS IL. Der Befehl "box" führt ein Boxing eines Integers durch. Dabei wird der Integerwert von einem Valuetype zu einem Referenztyp umgebaut. Auf dem Stack liegt nach dem Boxing die Adresse des Integer-Werts. Diese Adresse wird dann verwendet um den Wert in die Variable "\_a" mit dem Befehl "stsfld"(Store Static Field) zu speichern.\\
\begin{figure}[H]
\centering
\begin{lstlisting}[language=CIL,backgroundcolor=\color{backcolor}]
IL_001a:  box        [mscorlib]System.Int32
//----------Instrumented Code...----------------
IL_001f:  ldsflda    object TestProgram.Program::_a
IL_0024:  ldc.i4.s   31
IL_0026:  ldstr      "System.Void TestProgram.Program::Test()"
IL_002b:  call       void [DPCLibrary]DPCLibrary.DpcLibrary::
                                 WriteAccess(int32,int32,string)
//----------...End Instrumentation--------------
IL_0030:  stsfld     object TestProgram.Program::_a
\end{lstlisting}
\caption{Instrumentierter IL Code}\label{example_instrumentedCode}
\end{figure}
\autoref{example_instrumentedCode} zeigt den Code nach dem der Dynamic Parallel Checker diesen instrumentiert hat. Wie in \autoref{example_codeWithoutInstrum}, startet der Code mit "box" und endet mit "stsfld". Dazwischen wurde der Code um den Dynamic Parallel Checker erweitert. Um zu wissen auf welche Variable der Schreibzugriff durchgeführt wird, wird mit "ldsflda" (Load static Field Address) die Adresse der Resource ausgelesen und auf den Stack gelegt. Danach wird die Zeilennummer des Schreibzugriff auf den Stack gelegt (Man beachte: Die Zeilennummer zeigt die Zeile vor der Instrumentation) um bei einem Fehler aufzuzeigen, welche Code Zeilen diesen verursacht haben. Daher wird auch als nächstes der Methodennamen als String auf den Stack gelegt. Als letzte instrumentierte Zeile werden dann die Informationen an den Dynamic Parallel Checker übergeben. Dies wird mit der Methode "WriteAccess(int32,int32,string)" durchgeführt. Nach dem Instrumentierten Code hat der Stack wieder den gleichen Zustand wie nach dem "Box" Befehl in \autoref{example_codeWithoutInstrum}.
\end{flushleft}
\subsubsection{Vector Clock pro Thread}
\begin{flushleft}
Die Vector Clock eignet sich optimal for die History des Dynamic Parallel Checkers. Jeder Thread erhält seine eigene Vektor Clock, in der er die Zeitstempel der anderen Threads mitführt. Es wird nicht der aktuelle Zeitstempel mitgeführt, sondern der Zeitstempel der bei der letzten direkten oder indirekten Synchronisation mit diesem Thread von diesem Thread mitgeliefert wurde. Bei einem Synchronisationspunkt wird die Vector Clock mit der Vector Clock aus der Lock-History synchronisiert. (sh. \ref{lock_history}) Die Reihenfolge der Synchronisation ist jedoch nicht deterministisch und hängt vom Scheduler ab.\\
Unser Algorithmus verwendet die Vector Clock des aktuellen Threads um diese mit den Vector Clocks der History der anderen Threads zu vergleichen, um herauszufinden welche Zugriffe neben läufig zu dem aktuellen Zugriff stattgefunden haben. Daher ist es sehr wichtig, dass jeder Thread seine eigene Vector Clock hat.
\end{flushleft}
\subsubsection{Lock-History}\label{lock_history}
\begin{flushleft}
Während der kompletten Überwachung wird eine Lock-History (\autoref{example_lockHistory}) geführt. Diese beinhaltet die Information welcher Thread auf welche Ressource zu welcher Zeit (Vector Clock) einen Lock durchgeführt hat. Diese Information wird benötigt um z.B. eine Synchronisation zwischen dem Thread, der den letzten Unlock auf eine Ressource durchgeführt hat, mit dem aktuellen Thread, der nun einen Lock auf die selbe Ressource durchführen möchte, vorzunehmen. Bei jedem Unlock wird ein neuer Lock-History Eintrag erstellt, falls noch keiner vorhanden ist. Sollte jedoch bereits einer vorhanden sein, wird dieser einfach überschrieben.\\
\end{flushleft}
\begin{figure}[H]
\begin{center}
\textbf{\textit{Lock-History:}}\\[0.5cm]
\begin{tabular}{ c c c }
  Vektor & Ressource & ThreadNr \\\hline
  (2,1,0) & locka & 1 \\
  (0,1,0) & lockb & 2 \\\hline\\
\end{tabular}
\caption{Beispiel Lock-History}\label{example_lockHistory}
\end{center}
\end{figure}
\textbf{Synchronisation der Vector Clock}
\begin{flushleft}
Wenn z.B. im Beispielprogramm (\autoref{basic_example}) Thread1 (T1) vor Thread3 (T3) in den Lock(a) Bereich kommt, schreibt er beim Verlassen des gesicherten Bereichs einen Eintrag in die Lock-History. Wenn nun T3 den Lock(a) beziehen möchte, prüft der Algorithmus zuerst, ob ein Eintrag in der Lock-History vorhanden ist. Ist die der Fall, wird die eigene Vector Cock (a3, b3, c3) mit der Vector Clock des History Eintrags (a1, b1, c1) synchronisiert. (\autoref{example_vectorClockSync})\\
\newpage
Vorgehensweise bei der Synchronisation:
\begin{itemize}
\item Bei jeder ThreadId oder TaskId, die in den beiden Vector Clock vorkommt, wird der grössere Wert aus beiden Vector Clocks verwendet. z.B. MAX(a1, a2)
\item Die synchronisierende Vector Clock inkrementiert den Wert der eigenen ThreadId oder TaskId. z.B. MAX(c1, c3) + 1
\end{itemize}
\begin{figure}[H]
\[
	T1 = \begin{pmatrix}
		T1 & 2\\
		T2 & 1\\
	\end{pmatrix},
	T3_{alt} = \begin{pmatrix}
		T2 & 2\\
		T3 & 3\\
	\end{pmatrix} =>
	T3_{neu} = \begin{pmatrix}
		T1 & MAX(2, 0) = 2\\
		T2 & MAX(1, 2) = 2\\
		T3 & MAX(0, 3) + 1 = 4\\
	\end{pmatrix}
\]
\caption{Beispiel Vector Clock Synchronisation}\label{example_vectorClockSync}
\end{figure}
Somit stehen alle Zugriffe, von vor der Synchronisation von Thread1, in der Happened-Before Beziehung mit allen Zugriffen von Thread3 nach der Synchronisation. Somit können diese Zugriffe keine Race Condition darstellen.
\end{flushleft}
\subsubsection{Vector Clock Algorithmus}\label{vector_algorithm}
\begin{flushleft}
Mit Hilfe der Instrumentierung wird bei jedem Auftreten eines Ereignisses (Lese- oder Schreibzugriff, Lock oder Unlock auf Ressource, Start eines Threads usw.) unsere Dynamic Parallel Checker Library aufgerufen und anschliessend unser Algorithmus durchlaufen.\\[0.3cm]
Handelt es sich bei dem Ereignis im einen Lock auf eine Ressource, wird das Ablaufdiagramm in \autoref{algo_lock} durchlaufen. Zuerst wird überprüft, ob in der Lock-History bereits ein Eintrag vorhanden ist, der auf die gleiche Ressource lautet. Ist dies der Fall, findet eine Synchronisation zwischen der Vector Clock des aktuellen Threads und der Vector Clock des Eintrags in der Lock-History statt. Die Synchronisation ist in \ref{lock_history} beschrieben.\\
\begin{figure}[H]
	\includegraphics[width=13cm,height=5.5cm,trim=70mm 106mm 80mm 8mm, clip]{images/Lock.pdf}
\caption{Algorithmus - Lock}\label{algo_lock}
\end{figure}
Handelt es sich bei dem Ereignis um einen Unlock auf eine Ressource, wird das Ablaufdiagramm in \autoref{algo_unlock} durchlaufen. Es wird sichergestellt, dass die aktuelle Vector Clock zu der Ressource in die Lock-History geschrieben wird. Dabei wird überprüft, ob bereits ein Eintrag zu dieser Ressource in der Lock-History vorhanden ist. Wenn ja, wird dieser mit der neuen Zeit und der ThreadId oder TaskId überschrieben. Falls kein Eintrag vorhanden ist wird ein Neuer erstellt. Zudem wird der eigene Wert in der Vector Clock des aktuellen Threads oder Tasks inkrementiert. Dies dient dazu, dass beim nächsten Auftreten eines Locks auf dieselbe Ressource, nach der Synchronisation, die Happened-Before Beziehung gilt. \\
\begin{figure}[H]
	\includegraphics[width=15cm,height=5.5cm,trim=70mm 110mm 50mm 5mm, clip]{images/Unlock.pdf}
\caption{Algorithmus - Unlock}\label{algo_unlock}
\end{figure}
Handelt es sich bei dem Ereignis um einen Lese- oder Schreibzugriff auf eine Ressource, wird das Ablaufdiagramm in \autoref{algo_readwrite} durchlaufen. Zuerst wird das Ereignis in die Program-History des aktuellen Threads oder Tasks abgelegt. Sollte während der selben Vector Clock Zeit, im aktuellen Thread, bereits ein Zugriff auf diese Ressource stattgefunden haben, wird der Zugriffstyp (Read oder Write) aktualisiert. Solange nur Lesezugriffe stattgefunden haben ist der Zugriffstyp immer "Read". Sobald jedoch ein Schreibzugriff stattgefunden hat wird dieser Typ auf "Write" geändert und wird nie mehr den Type "Read" erhalten. Dadurch wurde die Datenstruktur optimiert.\\
Anschliessend wird das aktuelle Ereignis auf Race Conditions geprüft. Dafür benötigt unser Algorithmus alle Zugriffe, von den anderen Threads oder Tasks, die neben läufig zu dem aktuellen Zugriff aufgetreten sind. Dies kann mit Hilfe der Happened-Before Beziehung überprüft werden. In einem dynamischen Checker hat das Scheduling einen grossen Einfluss auf die Reihenfolge der einzelnen Zugriffe und kann dadurch die Happened-Before Beziehungen zwischen zwei Zugriffen ändern.\\
Hat einer dieser neben läufigen Zugriffe auf die selbe Ressource zugegriffen, wird überprüft ob es sich dabei um eine Race Condition handelt. Mehr Informationen zu Race Conditions in Kapitel \ref{race_conditons}. Sollte eine Race Condition erkannt werden, wird diese mit Hilfe des Logging Frameworks NLog an die WPF Applikation gemeldet und dem Benutzer angezeigt.
\begin{figure}[H]
	\includegraphics[width=15cm,height=5.5cm,trim=70mm 108mm 50mm 7mm, clip]{images/ReadWrite.pdf}
\caption{Algorithmus - Read/Write}\label{algo_readwrite}
\end{figure}
\end{flushleft}
\textbf{Algorithmus Beispiel}
\begin{flushleft}
In diesem Kapitel wird der Algorithmus auf das Beispielprogramm  in \autoref{basic_example} angewendet. Dabei ist zu beachten, dass dieses Beispiel lediglich eine mögliche Ablaufsequenz aufzeigt. Änderst sich das Scheduling, ändert sich auch das komplette Verhalten des Algorithmus.\\
\begin{itemize}
\item \textit{Alle Threads werden gestartet. Jede Instanz eines Threads oder Tasks instanziiert eine neue Vector Clock. Die Lock-History sowie die Programm-History ist noch leer.}\\[0.3cm]
\begin{tabular}{ c c c }
  	Vektor & Ressource & ThreadNr \\\hline
  	  &   &   \\\hline
\end{tabular}\hspace*{0.5cm}
\begin{tabular}{ c c c c }
  	ThreadNr & Ressource & Vektor & ZugriffsTyp \\\hline
  	  &   &   &   \\\hline
\end{tabular}
\[
	T1 = \begin{pmatrix}
		T1 & 1\\
	\end{pmatrix}
	, T2 = \begin{pmatrix}
		T2 & 1\\
	\end{pmatrix}
	, T3 = \begin{pmatrix}
		T3 & 1\\
	\end{pmatrix}
\]
\item \textit{lock(lockb), w(b), unlock(lockb) von Thread2}\\[0.3cm]
\begin{tabular}{ c c c }
  	Vektor & Ressource & ThreadNr \\\hline
  	(0,1,0) & lockb & 2 \\\hline
\end{tabular}\hspace*{0.5cm}
\begin{tabular}{ c c c c }
  	ThreadNr & Ressource & Vektor & ZugriffsTyp \\\hline
  	2 & b & (0,1,0) & write \\\hline
\end{tabular}
\[
	T1 = \begin{pmatrix}
		T1 & 1\\
	\end{pmatrix}
	, T2 = \begin{pmatrix}
		T2 & 2\\
	\end{pmatrix}
	, T3 = \begin{pmatrix}
		T3 & 1\\
	\end{pmatrix}
\]
\item \textit{lock(locka), w(a), unlock(locka) von Thread1}\\[0.3cm]
\begin{tabular}{ c c c }
  	Vektor & Ressource & ThreadNr \\\hline
  	(1,0,0) & locka & 1 \\
  	(0,1,0) & lockb & 2 \\\hline
\end{tabular}\hspace*{0.5cm}
\begin{tabular}{ c c c c }
  	ThreadNr & Ressource & Vektor & ZugriffsTyp \\\hline
  	1 & a & (1,0,0) & write \\
  	2 & b & (0,1,0) & write \\\hline
\end{tabular}
\[
	T1 = \begin{pmatrix}
		T1 & 2\\
	\end{pmatrix}
	, T2 = \begin{pmatrix}
		T2 & 2\\
	\end{pmatrix}
	, T3 = \begin{pmatrix}
		T3 & 1\\
	\end{pmatrix}
\]
\item \textit{lock(locka), w(a), unlock(locka) von Thread3}\\[0.3cm]
\begin{tabular}{ c c c }
  	Vektor & Ressource & ThreadNr \\\hline
  	(1,2,0) & locka & 3 \\
  	(0,1,0) & lockb & 2 \\\hline
\end{tabular}\hspace*{0.5cm}
\begin{tabular}{ c c c c }
  	ThreadNr & Ressource & Vektor & ZugriffsTyp \\\hline
  	1 & a & (1,0,0) & write \\
  	2 & b & (0,1,0) & write \\
  	3 & a & (1,2,0) & write \\\hline
\end{tabular}
\[
	T1 = \begin{pmatrix}
		T1 & 1\\
	\end{pmatrix}
	, T2 = \begin{pmatrix}
		T2 & 2\\
	\end{pmatrix}
	, T3 = \begin{pmatrix}
		T1 & 1\\		
		T3 & 3\\
	\end{pmatrix}
\]
\item \textit{w(b) von Thread2, w(b) von Thread3}\\[0.3cm]
\begin{tabular}{ c c c }
  	Vektor & Ressource & ThreadNr \\\hline
  	(1,2,0) & locka & 3 \\
  	(0,1,0) & lockb & 2 \\\hline
\end{tabular}
\[
	T1 = \begin{pmatrix}
		T1 & 1\\
	\end{pmatrix}
	, T2 = \begin{pmatrix}
		T2 & 2\\
	\end{pmatrix}
	, T3 = \begin{pmatrix}
		T1 & 1\\		
		T3 & 3\\
	\end{pmatrix}
\]
\item \textit{w(b) von Thread3}\\[0.3cm]
\begin{tabular}{ c c c }
  	Vektor & Ressource & ThreadNr \\\hline
  	(1,2,0) & locka & 3 \\
  	(0,1,0) & lockb & 2 \\\hline
\end{tabular}
\[
	T1 = \begin{pmatrix}
		T1 & 1\\
	\end{pmatrix}
	, T2 = \begin{pmatrix}
		T2 & 2\\
	\end{pmatrix}
	, T3 = \begin{pmatrix}
		T1 & 1\\		
		T3 & 3\\
	\end{pmatrix}
\]
\end{itemize}
\end{flushleft}
\subsection{Schlussfolgerungen}
TODO
\subsubsection{Technische Findings}
TODO\\
-Task/Threads
-GC bringt Probleme
\subsubsection{Persönliches Fazit}
TODO
\subsection{Backlog}
TODO
\section{Glossar}
- Partielle Ordnung\\
- Totale Ordnung
\section{Abbildungsverzeichnis}
\makeatletter
\@starttoc{lof}
\makeatother
\section{Literaturverzeichnis}
\renewcommand{\section}[2]{}%
\begin{thebibliography}{xxxxxxxxxxxxx}
\bibitem[ECMA, 2012]{ecma}"Standard ECMA-335 Common Language Infrastructure (CLI)", http://www.ecma-international.org/publications/standards/Ecma-335.htm, 06.2012
\bibitem[MCA, 1978]{MCA}"Time, Clocks, and the Ordering of Events in a Distributed System" http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf, 07.1978
\bibitem[ACSC, 1988]{acsc}"Timestamps in Message-Passing Systems That Preserve the Partial Ordering" http://zoo.cs.yale.edu/classes/cs426/2012/lab/bib/fidge88timestamps.pdf, 02.1988
\end{thebibliography}
\end{document}
