\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{german}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage[german]{babel}
\usepackage{geometry}
\usepackage{listings}
\usepackage{hyperref}
\usepackage[onehalfspacing]{setspace}
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{DejaVuSans}
\usepackage[T1]{fontenc}

\renewcommand*{\familydefault}{\sfdefault}
\geometry{verbose,a4paper,tmargin=35mm,bmargin=35mm,lmargin=25mm,rmargin=25mm}
\author{Dominik Heeb, Fabian Keller}
\title{Dynamic Paralle Checker}
\pagestyle{fancy}
\fancyhead{}
\fancyhead[L]{Dynamic Paralle Checker}
\fancyhead[R]{Domink Heeb, Fabian Keller}
\fancyfoot{}
\fancyfoot[R]{Seite \thepage}

\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}
\lstset{language=[Sharp]C,
captionpos=b,
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\normalsize,}

\usepackage{amsmath}
\usepackage[some]{background}
\usepackage{lipsum}

\definecolor{titlepagecolor}{cmyk}{1,.20,0,.25}

\DeclareFixedFont{\bigsf}{T1}{phv}{b}{n}{1.5cm}

\backgroundsetup{
scale=1,
angle=0,
opacity=1,
contents={\begin{tikzpicture}[remember picture,overlay]
 \path [fill=titlepagecolor] (-0.5\paperwidth,5) rectangle (0.5\paperwidth,10);  
\end{tikzpicture}}
}
\makeatletter                       
\def\printauthor{%                  
    {\LARGE Studenten:\\\vspace{10pt}
    \large \@author \\\vspace{20pt}
    \LARGE Dozent:\\\vspace{10pt}
    \large Prof. Dr. Luc Bläser \\
	\texttt{lblaeser@hsr.ch}}}            
\makeatother
\author{%
    Fabian Keller \\
    Semester 5 \\
    \texttt{f3keller@hsr.ch}\vspace{15pt} \\
    Dominik Heeb \\
    Semester 5 \\
    \texttt{d1heeb@hsr.ch}
    }
\renewcommand{\listfigurename}{}
\begin{document}
\begin{titlepage}
\BgThispage
\newgeometry{left=1cm,right=4cm}
\vspace*{2cm}
\noindent
\textcolor{white}{\bigsf Dynamic Parallel Checker\\[0.5cm] \begin{huge}Semesterarbeit - Technische Dokumentation\end{huge}}
\vspace*{2.0cm}\par
\noindent
\begin{minipage}{0.35\linewidth}
    \begin{flushright}
        \printauthor
    \end{flushright}
\end{minipage} \hspace{15pt}
%
\begin{minipage}{0.02\linewidth}
    \rule{1pt}{300pt}
\end{minipage} \hspace{40pt}
%
\begin{minipage}{0.6\linewidth}
\begin{center}
\begin{huge}
Eine Studie über Dynamic Parallel Checking Methoden
\end{huge}
\end{center}
\end{minipage}
\end{titlepage}
\restoregeometry

\newpage
\tableofcontents 
\newpage

\section{Abstract}
\begin{flushleft}
In diesem Projekt werden verschiedene Methoden zur dynamischen Analyse von Parallelem Code evaluiert. Dafür wird ein Dynamic Parallel Checker Prototyp entwickelt, der während der Laufzeit überprüft ob Nebenläufigkeitsfehler (Race Conditions) auftreten. Ebenfalls Inhalt dieses Projekts ist es, einen eigenen Algorithmus zu entwickeln, der die Laufzeitanalyse ermöglicht. Diesbezüglich haben wir uns für einen Algorithmus entschieden, der mit Hilfe einer Vector Clock eine partielle Ordnung innerhalb der Lese- und Schreibzugriffe von den verschiedenen Threads herstellen kann.\\

\end{flushleft}
\section{Technischer Bericht}
\subsection{Einleitung und Übersicht}
\subsubsection{Dynamic Checker}
\begin{flushleft}
Um Race Conditions (sh. \ref{race_conditons}) zu erkennen, gibt es verschiedene Ansätze. Zwei davon sind, der Dynamic Checker und der Static Checker. In diesem Projekt
wird ein Dynamic Checker entwickelt. Ein dynamic Checker hat die Aufgabe, Race Conditions zur Laufzeit (dynamic) zu erkennen. Der Static Checker
im Gegensatz behandelt das Erkennen zur Entwicklungszeit. Um einen Dynamic Checker realisieren zu können, muss ein fertiges Programm instrumentiert werden.
Mit Instrumentation ist gemeint, dass der Kompilierte Code angepasst wird, so dass er während der Laufzeit einen Erkennungsalgorithmus ausführen kann, jedoch nicht das Verhalten des Programms verändert.\\
Der Checker analysiert hauptsächlich Lese- und Schreibzugriffe auf Variablen. Um die Präzision zu erhöhen, müssen auch Lock/ Unlock und Thread.Start usw. ausgelesen werden.\\
Mehr informationen dazu unter: \ref{vector_algorithm} Vector Clock Algorithmus
\end{flushleft}
\subsubsection{Race Condition}\label{race_conditons}
\begin{flushleft}
Bei Race Conditions handelt es sich um Speicherzugriffsfehler. Diese können durch richtige synchronisation (Codeteile, in welchen nur ein Thread gleichzeitig arbeiten kann) verhindert werden. In \autoref{fig:exampleRaceCondition} wird ein Code beschrieben, welcher diese Synchronisation komplett weglässt und daher Race Conditions entstehen.
\begin{figure}[h]
\centering
\begin{tabular}{|cc|}
\hline
\multicolumn{2}{|c|}{Konto = 100} \\ 
 &  \\ 
Thread 1 & Thread 2 \\ 
Konto + 200 & Konto - 100 \\ 
\hline
\end{tabular}
\caption[Beispiel Race Condition]{Ein unsynchronisierter Zugriff auf ein Konto}
\label{fig:exampleRaceCondition}
\end{figure}\\
Wenn zwei Threads den Code unter \autoref{fig:exampleRaceCondition} parallel ausführen, ist nicht deterministisch welcher Thread wann durchgeführt wird. Die Situation in \autoref{fig:exampleRaceCondition2} kann dadurch entstehen. Dabei erfährt der zweite Thread nicht, das der erste Thread den Wert angepasst hat und überschreibt den Wert mit seinen falschen Daten.\\
\begin{figure}[h]
\centering
\begin{tabular}{|cc|}
\hline
Thread 1 & Thread 2\\
Lesen Konto = 100 & \\
& Lesen Konto = 100\\
Addieren 100 + 200 & Addieren 100 - 100\\
Speichern 300 &\\
& Speichern 0\\
\multicolumn{2}{|c|}{Konto = 0}\\
\hline
\end{tabular}
\caption[Race Condition]{Ablauf eines unnsynchronisierten Zugriff}
\label{fig:exampleRaceCondition2}
\end{figure}
Race Conditions wie unter \autoref{fig:exampleRaceCondition2} sind gefährlich, da kein effektiver Fehlzustand im System ensteht, sondern Werte nicht richtig angepasst werden. Race Conditions zeichnen sich auch daher aus, dass sie stark vom Verarbeitungsablauf abhängen und daher nicht immer auftreten müssen. Wenn also die Threads in \autoref{fig:exampleRaceCondition2} in der richtigen Reihenfolge verarbeitet werden, wird kein Fehler entstehen.\\

\end{flushleft}
\subsubsection{Vector Clock}
Die einzelnen Lese- und Schreibzugriffe in einem System können asynchron in unterschiedlichen Threads ablaufen und dadurch nicht in eine totale Ordnung gebracht werden. Um nun jedem einzelnen Zugriff einen Zeitstempel zuzuordnen verwenden wir eine Vector Clock. Diese Vector Clock wird benötigt um eine Aussage über die Nebenläufigkeit der einzelnen Zugriffe zu machen.\\
Die Vector Clock basiert auf der Lamport's Clock von Leslie B. Lamport. Jeder Teilnehmer in einem System, in unserem Fall wären dies die einzelnen Threads, besitzt ein eigener Zeitstempel. Der eigene Zeitstempel kann unabhängig inkrementiert werden. Eine Synchronisation zwischen den Zeitstempeln der Threads findet jedoch nur statt wenn ein Synchronisationspunkt vorliegt. Ein Synchronisationspunkt ist z.B. wenn ein Thread 1 ein Lock auf ein Objekt a macht und zuvor ein anderer Thread 2 ein Unlock auf das Objekt a gemacht hat. Dadurch ist sichergestellt, dass jeder Zugriff vor dem Unlock von Thread 1 sicher vor jedem Zugriff nach dem Lock von Thread 2 stattgefunden hat. In diesem Fall wird nun der Zeitstempel von Thread 2 mit dem Zeitstempel von Thread 1 synchronisiert. Der Zeitstempel von Thread 1 bleibt wie gehabt. Mehr Informationen über die einzelnen Synchronisationspunkte finden Sie im Kapitel \ref{implementation} Implementation.\\
Die Vector Clock erweitert die Lamport Clock nun dadurch, dass jeder Thread nicht nur einen globalen Zeitstempel besitzt sondern einen Vektor, der für jeden Thread einen eigenen Zeitstempel mitführt. D.h. jeder Thread besitzt nun einen eigenen Vektor mit den Zeitstempeln der anderen Threads. Jedoch befindet sich darin nicht der aktuelle Zeitstempel sondern der Zeitstempel der letzten Synchronisation mit dem jeweiligen Thread. Mit Hilfe der Vector Clock kann nun eine Aussage über die Nebenläufigkeit der einzelnen Lese- und Schreibzugriffe eines Thread gemacht werden.
\subsubsection{Happened-Before Beziehung}
\begin{flushleft}
Um mit Hilfe der Vector Clock die Nebenläufigkeit von Lese- und Schreibzugriffe zu bestimmen, verwenden wir die Happened-Before Beziehung von Leslie B. Lamport. Diese Beziehung wird in der Lamport Clock und in der Vector Clock verwendet um eine partielle Ordnung innerhalb mehreren Ereignissen herzustellen. Bei neben läufigen Programmen kann keine totale Ordnung erreicht werden, daher muss mit einer partiellen Ordnung gearbeitet werden.\\
Unser Algorithmus vergleicht lediglich die Zugriffe, die neben läufig stattgefunden haben und verwendet dazu die Happened-Before Beziehung.\\
Die Happened-Before Beziehung ermöglicht es dann eine Aussage zu den Beziehungen zwischen den einzelnen Lese- und Schreibzugriffe der unterschiedlichen Thread oder Tasks zu machen.\\[0.5cm]
Eigenschaften der Happened-Before Beziehung:
\begin{itemize}
\item Auf demselben Thread oder Task: a -> b wenn die Zeit von a < b. (Zeit ist durch Vector Clock gegeben)
\item Wenn eine Synchronisation zwischen zwei Threads oder Tasks durchgeführt wurde, dann a -> b wenn a der Thread oder Task ist von dem aus synchronisiert wird und b der Thread oder Task ist zu dem synchronisiert wird.
\item Für drei Zugriffe mit Synchronisation a, b, c, wenn a -> b und b -> c, dann a -> c (Transitivität)
\end{itemize}
Unser Algorithmus vergleicht jede Komponente der Vector Clock von Zugriff a mit der passenden Komponente der Vector Clock von Zugriff b. Dabei können zwei verschiedene Beziehungen bestehen:\\[0.5cm]
\textbf{{\small Happened Before}}\\
Test
\\[0.5cm]
\textbf{{\small Concurrent}}\\
Test
\end{flushleft}
\subsection{Implementation}\label{implementation}
In diesem Kapitel wird die Implementation der 
\subsubsection{Vector Clock Algorithmus}\label{vector_algorithm}
\subsubsection{Vector Clock pro Thread}
\subsubsection{Lock-History}
\subsubsection{Funktion}
\subsection{Schlussfolgerungen}
\subsection{Backlog}
\section{Glossar}
- Partielle Ordnung\\
- Totale Ordnung
\section{Abbildungsverzeichnis}
\listoffigures
\section{Literaturverzeichnis}
\renewcommand{\section}[2]{}%
\begin{thebibliography}{xxxxxxxxxxxxx}
\bibitem[BMBF, 2003]{bmbf}"'IT-Ausstattung der allgemein bildenden und berufsbildenden 
                         Schulen in Deutschland"', http://www.schulen-ans-netz.de/   
                         neuemedien/fakten/dokus/it-ausstattung-2003.pdf, 10.03.2005	
\end{thebibliography}
\end{document}